name: FE CI/CD

on:
  pull_request:
    branches: ["main", "dev"]
    paths-ignore:
      - ".github/workflows/rollback.yml"
  push:
    branches: ["main", "dev"]
    paths-ignore:
      - ".github/workflows/rollback.yml"
  workflow_dispatch: {}

permissions:
  id-token: write
  contents: read

concurrency:
  group: fe-ci-cd-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  RELEASE_ID: ${{ github.sha }}
  DOCKER_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/daeng-map-frontend
  MESSAGE: >-
    ${{
      github.event.pull_request.title ||
      github.event.head_commit.message ||
      github.workflow
    }}

jobs:
  ci:
    name: CI
    runs-on: ubuntu-latest
    timeout-minutes: 20

    defaults:
      run:
        working-directory: daengdong

    # - PR: base branch ê¸°ì¤€(main=prod, dev=dev)
    # - push: ë¸Œëœì¹˜ ê¸°ì¤€(main=prod, dev=dev)
    environment:
      name: >-
        ${{
          (github.event_name == 'pull_request' && github.base_ref == 'main') && 'prod' ||
          (github.event_name == 'pull_request') && 'dev' ||
          (github.ref_name == 'main' && 'prod') ||
          'dev'
        }}

    steps:
      - name: Mark CI start
        id: ci_time
        run: echo "start=$(date +%s)" >> "$GITHUB_OUTPUT"
        working-directory: .

      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10
          run_install: false

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "24"
          cache: "pnpm"
          cache-dependency-path: daengdong/pnpm-lock.yaml

      - name: Install
        id: time_install
        run: |
          start=$(date +%s)
          pnpm install --frozen-lockfile
          end=$(date +%s)
          echo "start=${start}" >> "$GITHUB_OUTPUT"
          echo "end=${end}" >> "$GITHUB_OUTPUT"

      - name: Lint
        id: time_lint
        run: |
          start=$(date +%s)
          pnpm lint
          end=$(date +%s)
          echo "start=${start}" >> "$GITHUB_OUTPUT"
          echo "end=${end}" >> "$GITHUB_OUTPUT"

      - name: Test (if present)
        id: time_test
        run: |
          start=$(date +%s)
          set -euo pipefail

          if pnpm -s run | grep -qE '^test'; then
            pnpm test
            result="ran"
          else
            result="skipped"
            echo "[INFO] No test script. Skipping."
          fi

          end=$(date +%s)
          echo "start=${start}" >> "$GITHUB_OUTPUT"
          echo "end=${end}" >> "$GITHUB_OUTPUT"
          echo "result=${result}" >> "$GITHUB_OUTPUT"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image
        id: time_build
        uses: docker/build-push-action@v6
        with:
          context: daengdong
          push: true
          tags: |
            ${{ env.DOCKER_IMAGE }}:${{ env.RELEASE_ID }}
            ${{ env.DOCKER_IMAGE }}:latest
          build-args: |
            NEXT_PUBLIC_API_BASE_URL=${{ vars.NEXT_PUBLIC_API_BASE_URL }}
            NEXT_PUBLIC_NAVER_MAP_CLIENT_ID=${{ vars.NEXT_PUBLIC_NAVER_MAP_CLIENT_ID }}
            NEXT_PUBLIC_MISSION_TEST_MODE=${{ vars.NEXT_PUBLIC_MISSION_TEST_MODE }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Mark CI end
        id: ci_time_end
        if: always()
        run: echo "end=$(date +%s)" >> "$GITHUB_OUTPUT"
        working-directory: .

      - name: Notify (CI)
        if: always()
        env:
          WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_URL }}
          MESSAGE: ${{ env.MESSAGE }}
          JOB_STATUS: ${{ job.status }}
          RELEASE_ID: ${{ env.RELEASE_ID }}
          ACTOR: ${{ github.actor }}
          ENV_NAME: >-
            ${{
              (github.event_name == 'pull_request' && github.base_ref == 'main') && 'prod' ||
              (github.event_name == 'pull_request') && 'dev' ||
              (github.ref_name == 'main' && 'prod') ||
              'dev'
            }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          TIMESTAMP: ${{ github.event.head_commit.timestamp || github.event.pull_request.updated_at }}
          CI_START: ${{ steps.ci_time.outputs.start }}
          CI_END: ${{ steps.ci_time_end.outputs.end }}
          INSTALL_S: ${{ steps.time_install.outputs.start }}
          INSTALL_E: ${{ steps.time_install.outputs.end }}
          LINT_S: ${{ steps.time_lint.outputs.start }}
          LINT_E: ${{ steps.time_lint.outputs.end }}
          TEST_S: ${{ steps.time_test.outputs.start }}
          TEST_E: ${{ steps.time_test.outputs.end }}
          TEST_RESULT: ${{ steps.time_test.outputs.result }}
        run: |
          set -euo pipefail

          # WEBHOOK ì—†ìœ¼ë©´ ìŠ¤í… ì¢…ë£Œ
          [ -z "${WEBHOOK:-}" ] && echo "âš ï¸ DISCORD_WEBHOOK_URLì´ ê³µë°±ì´ë¯€ë¡œ ë³¸ ë‹¨ê³„ë¥¼ ìŠ¤í‚µí•©ë‹ˆë‹¤." && exit 0

          # ì•ˆì „í•œ ì‚°ìˆ  ê³„ì‚°ìš© í•¨ìˆ˜
          dur() { local s="${1:-}" e="${2:-}"; [ -n "$s" ] && [ -n "$e" ] && echo $((e - s)) || echo 0; }

          install_sec="$(dur "${INSTALL_S:-}" "${INSTALL_E:-}")"
          lint_sec="$(dur "${LINT_S:-}" "${LINT_E:-}")"
          ci_seconds="$(dur "${CI_START:-}" "${CI_END:-}")"
          test_sec="$(dur "${TEST_S:-}" "${TEST_E:-}")"

          if [ "$JOB_STATUS" = "success" ]; then
            TITLE="âœ… [FE / ${ENV_NAME}] CI Success"
            COLOR=5763719
          else
            TITLE="âŒ [FE / ${ENV_NAME}] CI Failed"
            COLOR=15548997
          fi

          test_label="${test_sec}s"
          if [ "${TEST_RESULT}" = "skipped" ]; then
            test_label="skipped"
          fi

          # ê°œí–‰ ë¬¸ì ë° ë”°ì˜´í‘œ ì œê±°, 200ìë¡œ ìë¦„
          safe_msg=$(echo "$MESSAGE" | tr '\n' ' ' | sed 's/"/\\"/g' | head -c 200)

          JSON_PAYLOAD=$(cat <<JSON
          {
            "embeds": [
              {
                "title": "$TITLE",
                "url": "$RUN_URL",
                "color": $COLOR,
                "description": "${safe_msg}",
                "fields": [
                  {"name":"Release ID","value":"\`${RELEASE_ID}\`","inline":false},
                  {"name":"Actor","value":"${ACTOR}","inline":true},
                  {"name":"Total CI","value":"${ci_seconds}s","inline":true},

                  {"name":"Install","value":"${install_sec}s","inline":true},
                  {"name":"Lint","value":"${lint_sec}s","inline":true},
                  {"name":"Test","value":"${test_label}","inline":true},

                  {"name":"Docker Image","value":"pushed","inline":true}
                ],
                "timestamp": "$TIMESTAMP"
              }
            ]
          }
          JSON
          )

          curl -sS -X POST -H "Content-Type: application/json" --data-binary "$JSON_PAYLOAD" "$WEBHOOK" || true

  cd:
    name: CD
    runs-on: ubuntu-latest
    needs: ci
    timeout-minutes: 15

    # pushì¼ ë•Œë§Œ ë°°í¬
    if: github.event_name == 'push'

    permissions:
      id-token: write
      contents: read

    environment:
      name: ${{ github.ref_name == 'main' && 'prod' || 'dev' }}
    env:
      ENV_NAME: ${{ github.ref_name == 'main' && 'prod' || 'dev' }}

    steps:
      - name: Mark CD start
        id: cd_time
        run: echo "start=$(date +%s)" >> "$GITHUB_OUTPUT"

      - name: Checkout (for docker-compose.yml)
        uses: actions/checkout@v4
        with:
          sparse-checkout: docker-compose.yml
          sparse-checkout-cone-mode: false

      - name: Configure AWS Credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ap-northeast-2

      - name: Upload docker-compose.yml to S3
        id: s3
        run: |
          aws s3 cp docker-compose.yml \
            "s3://${{ secrets.DEPLOY_BUCKET }}/${{ env.ENV_NAME }}/docker-compose.yml"
          echo "âœ… docker-compose.yml S3 ì—…ë¡œë“œ ì™„ë£Œ"

      - name: Update SSM Parameter (Docker image tag)
        id: ssm
        run: |
          aws ssm put-parameter \
            --name "${{ secrets.SSM_DOCKER_IMAGE_PARAM }}" \
            --value "${{ env.DOCKER_IMAGE }}:${{ env.RELEASE_ID }}" \
            --type String \
            --overwrite
          echo "âœ… SSM íŒŒë¼ë¯¸í„° ì—…ë°ì´íŠ¸ ì™„ë£Œ: ${{ env.DOCKER_IMAGE }}:${{ env.RELEASE_ID }}"

      - name: Create new Launch Template version
        id: lt
        run: |
          set -euo pipefail

          LT_ID="${{ secrets.FE_LAUNCH_TEMPLATE_ID }}"

          # í˜„ì¬ Launch Templateì˜ User Dataë¥¼ ìœ ì§€í•˜ë©´ì„œ
          # Descriptionë§Œ ë³€ê²½í•˜ì—¬ ìƒˆ ë²„ì „ ìƒì„±
          NEW_VERSION=$(aws ec2 create-launch-template-version \
            --launch-template-id "${LT_ID}" \
            --source-version '$Latest' \
            --version-description "deploy-${{ env.RELEASE_ID }}" \
            --launch-template-data '{}' \
            --query 'LaunchTemplateVersion.VersionNumber' \
            --output text)

          echo "version=${NEW_VERSION}" >> "$GITHUB_OUTPUT"
          echo "ğŸ“‹ ìƒˆ Launch Template ë²„ì „: ${NEW_VERSION}"

          # ASGê°€ í•­ìƒ ìµœì‹  ë²„ì „ì„ ì‚¬ìš©í•˜ë„ë¡ ì„¤ì •
          aws autoscaling update-auto-scaling-group \
            --auto-scaling-group-name "${{ secrets.FE_ASG_NAME }}" \
            --launch-template "LaunchTemplateId=${LT_ID},Version=\$Latest"

      - name: Start ASG Instance Refresh
        id: deploy
        run: |
          set -euo pipefail

          ASG_NAME="${{ secrets.FE_ASG_NAME }}"
          echo "ğŸš€ ASG Instance Refresh ì‹œì‘: ${ASG_NAME}"

          REFRESH_ID=$(aws autoscaling start-instance-refresh \
            --auto-scaling-group-name "${ASG_NAME}" \
            --preferences '{
              "MinHealthyPercentage": 100,
              "InstanceWarmup": 120,
              "SkipMatching": true
            }' \
            --query 'InstanceRefreshId' \
            --output text)

          echo "refresh_id=${REFRESH_ID}" >> "$GITHUB_OUTPUT"
          echo "ğŸ“‹ Instance Refresh ID: ${REFRESH_ID}"

      - name: Wait for Instance Refresh
        run: |
          set -euo pipefail

          ASG_NAME="${{ secrets.FE_ASG_NAME }}"
          REFRESH_ID="${{ steps.deploy.outputs.refresh_id }}"

          echo "â³ Instance Refresh ì™„ë£Œ ëŒ€ê¸° ì¤‘..."

          while true; do
            STATUS=$(aws autoscaling describe-instance-refreshes \
              --auto-scaling-group-name "${ASG_NAME}" \
              --instance-refresh-ids "${REFRESH_ID}" \
              --query 'InstanceRefreshes[0].Status' \
              --output text)

            PROGRESS=$(aws autoscaling describe-instance-refreshes \
              --auto-scaling-group-name "${ASG_NAME}" \
              --instance-refresh-ids "${REFRESH_ID}" \
              --query 'InstanceRefreshes[0].PercentageComplete' \
              --output text 2>/dev/null || echo "0")

            echo "ğŸ“Š ìƒíƒœ: ${STATUS} (${PROGRESS}%)"

            case "${STATUS}" in
              Successful)
                echo "âœ… Instance Refresh ì„±ê³µ!"
                break
                ;;
              Cancelled|Failed|RollbackSuccessful|RollbackFailed)
                echo "âŒ Instance Refresh ì‹¤íŒ¨: ${STATUS}"
                exit 1
                ;;
              *)
                sleep 15
                ;;
            esac
          done

      - name: Mark CD end
        id: cd_time_end
        if: always()
        run: echo "end=$(date +%s)" >> "$GITHUB_OUTPUT"

      - name: Notify (CD)
        if: always()
        env:
          WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_URL }}
          MESSAGE: ${{ env.MESSAGE }}
          JOB_STATUS: ${{ job.status }}
          RELEASE_ID: ${{ env.RELEASE_ID }}
          ACTOR: ${{ github.actor }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          TIMESTAMP: ${{ github.event.head_commit.timestamp }}
          CD_START: ${{ steps.cd_time.outputs.start }}
          CD_END: ${{ steps.cd_time_end.outputs.end }}
          S3_OUTCOME: ${{ steps.s3.outcome }}
          SSM_OUTCOME: ${{ steps.ssm.outcome }}
          DEPLOY_OUTCOME: ${{ steps.deploy.outcome }}
        run: |
          set -euo pipefail

          # WEBHOOK ì—†ìœ¼ë©´ ìŠ¤í… ì¢…ë£Œ
          [ -z "${WEBHOOK:-}" ] && echo "âš ï¸ DISCORD_WEBHOOK_URLì´ ê³µë°±ì´ë¯€ë¡œ ë³¸ ë‹¨ê³„ë¥¼ ìŠ¤í‚µí•©ë‹ˆë‹¤." && exit 0

          # ì•ˆì „í•œ ì‚°ìˆ  ê³„ì‚°ìš© í•¨ìˆ˜
          dur() { local s="${1:-}" e="${2:-}"; [ -n "$s" ] && [ -n "$e" ] && echo $((e - s)) || echo 0; }
          cd_seconds="$(dur "${CD_START:-}" "${CD_END:-}")"

          if [ "$JOB_STATUS" = "success" ]; then
            TITLE="âœ… [FE / ${ENV_NAME}] CD Success"
            COLOR=5763719
          else
            TITLE="âŒ [FE / ${ENV_NAME}] CD Failed"
            COLOR=15548997
          fi

          # ê°œí–‰ ë¬¸ì ë° ë”°ì˜´í‘œ ì œê±°, 200ìë¡œ ìë¦„
          safe_msg=$(echo "$MESSAGE" | tr '\n' ' ' | sed 's/"/\\"/g' | head -c 200)

          JSON_PAYLOAD=$(cat <<JSON
          {
            "embeds": [
              {
                "title": "$TITLE",
                "url": "${RUN_URL}",
                "color": $COLOR,
                "description": "${safe_msg}",
                "fields": [
                  {"name":"Release ID","value":"\`${RELEASE_ID}\`","inline":false},
                  {"name":"Actor","value":"${ACTOR}","inline":true},
                  {"name":"Total CD","value":"${cd_seconds}s","inline":true},

                  {"name":"Compose Upload","value":"${S3_OUTCOME}","inline":true},
                  {"name":"SSM Update","value":"${SSM_OUTCOME}","inline":true},
                  {"name":"Instance Refresh","value":"${DEPLOY_OUTCOME}","inline":true}
                ],
                "timestamp": "$TIMESTAMP"
              }
            ]
          }
          JSON
          )

          curl -sS -X POST -H "Content-Type: application/json" --data-binary "$JSON_PAYLOAD" "$WEBHOOK" || true